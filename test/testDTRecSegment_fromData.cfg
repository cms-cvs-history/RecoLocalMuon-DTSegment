##
# Test the production of the complete chain:
# from digi to RecSegment 4D, through RecHit1D and RecSegment2D
# starting from real cosmic data from commissioning
# Up to now only the Linear Drift alogo is available for the
# commisioning data.
##

process testDTRecSegmentfromData  = {
    include "CondCore/DBCommon/data/CondDBSetup.cfi"
    include "Geometry/MuonNumbering/data/muonNumberingInitialization.cfi"
    
    # Mapping of the channels
    es_source roMapping = PoolDBESSource {
	using CondDBSetup
	string connect ="sqlite_file:/afs/cern.ch/cms/Physics/muon/CMSSW/DT/SQLLite/TestYB0/channelsMap_new/mapWh0.db"
	string timetype = "runnumber"
	untracked uint32 authenticationMethod = 0
	VPSet toGet = {{
		string record = "DTReadOutMappingRcd"
		string tag = "channelsMap"
	    }}
    }
    
    # Event Formatter
    source = DaqSource{
        untracked string readerPluginName = "DTDDUFileReader"
        untracked PSet readerPset = {
	    untracked string fileName='/castor/cern.ch/user/d/dtdqm/YB0/DT_W0S12_ALL_HanyT_Tech_frlpcS1D12-18_r15361.i0'
	    untracked bool isRaw = true
	}
    }
    
    untracked PSet maxEvents = {untracked int32 input = 1000}    
    
    # DT Unpacker
    module dtunpacker = DTUnpackingModule {
	string dataType = "DDU"
	untracked bool fedbyType = true
	untracked bool useStandardFEDid = true
	PSet readOutParameters  = {
	    untracked bool localDAQ = true
	    untracked bool performDataIntegrityMonitor = false
	    untracked bool debug = false
	    PSet rosParameters = {
		untracked bool localDAQ = true
		untracked bool readingDDU = true
		untracked bool writeSC = true
		untracked bool readDDUIDfromDDU = true
		untracked bool performDataIntegrityMonitor = false
		untracked bool debug = false
	    }
	}
    }
    
    # No Mag Field for the Commisioning Data
    #       include "MagneticField/Engine/data/volumeBasedMagneticField.cfi"
    
    include "Geometry/MuonCommonData/data/muonIdealGeometryXML.cfi"
    include "Geometry/DTGeometry/data/dtGeometry.cfi"
    
    # The tzero 
    es_source t0 = PoolDBESSource {
	using CondDBSetup
	VPSet toGet = {
	    {string record = "DTT0Rcd"
		string tag = "tzero_13_03_07"
	    } }
	bool loadAll = true
	string connect ="sqlite_file:/afs/cern.ch/cms/Physics/muon/CMSSW/DT/SQLLite/TestYB0/t0/t0.db"
	string timetype = "runnumber"
    }
    
    
    # The ttrig from DB
    es_source TTrig = PoolDBESSource { 
	using CondDBSetup
	string connect = "sqlite_file:/afs/cern.ch/cms/Physics/muon/CMSSW/DT/SQLLite/TestYB0/tTrig/tTrig_Sec12.db"
	string timetype = "runnumber"    
	untracked uint32 authenticationMethod = 0
	VPSet toGet = {{
		string record = "DTTtrigRcd" 
		string tag = "tTrig"}}
    }
    
    ## _Vdrift1D_ ##
    include "RecoLocalMuon/DTRecHit/data/dt1DRecHits_LinearDrift_CosmicData.cfi"
    #replace DTRecHit1DProducer.debug = true
    #replace DTRecHit1DProducer.recAlgoConfig.debug = true
    #replace DTRecHit1DProducer.recAlgoConfig.tTrigModeConfig.debug = true
    
    
    ## _Vdrift2D_ ##
    include "RecoLocalMuon/DTSegment/data/dt2DSegments_CombPatternReco2D_LinearDrift_CosmicData.cfi"
    
    ## _4DAlgo ##
    include "RecoLocalMuon/DTSegment/data/dt4DSegments_CombPatternReco4D_LinearDrift_CosmicData.cfi"
    
    ## _all1DHits_ ##	
    # CAVEAT if all1DHits = false: 
    #	1- the file must contain the 2D segments
    #	2- defined only for CombinatorialPatternReco
    #	replace DTSegment4DProducer.Reco4DAlgoConfig.AllDTRecHits = false
    
    
    ## _Reader_ ##
    module DTRecSegment4DAnalyzer = DTRecSegment4DReader {
	untracked bool debug = true
	untracked string rootFileName = "seg4D.root"
	string recHits4DLabel = "recseg4dbuilder"
    }
    
    
    
    module out = PoolOutputModule {
	untracked string fileName ="/tmp/rechit4D.root"
    }
    
    ## _ExecPath_ ##
    path p = {dtunpacker, dt1DRecHits, dt2DSegments, dt4DSegments}
    
    endpath this_is_the_end = {out}
}

